---
title: "Create Table of Network Model Edge Weights"
output:
  html_document:
    df_print: paged
---

# Read in libraries and data
```{r}
library(tidyverse)
library(kableExtra)
library(here)

PreToMid.fit <- read_rds(here('Fitted model objects','PreToMid.fit'))
MidToPost.fit <- read_rds(here('Fitted model objects','MidToPost.fit'))
PostTo3MFU.fit <- read_rds(here('Fitted model objects','PostTo3MFU.fit'))
my3mTo6mFU.fit <- read_rds(here('Fitted model objects','my3mTo6mFU.fit'))

PreToPost.fit <- read_rds(here('Fitted model objects','PreToPost.fit'))
PreTo6mFU.fit <- read_rds(here('Fitted model objects','PreTo6mFU.fit'))

```

# Set names of rows and columns

The network model itself does not store the names of the nodes, so input them here manually. Must match the order in which they were entered into the network.

```{r}

var_names <- tibble(names = c('ACTorMEUC','HADS','IESR','FCR','SCS','EAC','AAQc','CESD'))
```

# Generic function to create tidy adjacency matrix

```{r}


getTidyAdjacencyMatrix <- function(mgm_fit){
  
  # signs has 0s (undefined values) and NAs (non-sig edge values)
  # in it. We will just replace those with 1s for now.
  signs.tibble <- mgm_fit$pairwise$signs %>% 
    as_tibble() %>%
    mutate(across(everything(), ~replace(.x, .x %in% c(NA,0), 1)))
  
  adjacency.tibble <- mgm_fit$pairwise$wadj %>%
    as_tibble()
  
  # adjacency 
  adjacency_with_signs.tibble <- (signs.tibble * adjacency.tibble)
  
  
  adjacency.long <- 
    adjacency_with_signs.tibble %>%
    
    # rename columns as variable names
    rename_all(~var_names %>% pull(names)) %>%
    
    # add row names as variable names again
    mutate(variable_name_1 = var_names$names) %>%
    
    # format as long by variable 1 and variable 2
    pivot_longer(cols = ACTorMEUC:CESD, names_to = 'variable_name_2') %>%
    mutate(value = round(value,2)) %>%
    
    # remove redundant entries
    
   mutate(Var = map2_chr(variable_name_1, variable_name_2, ~toString(sort(c(.x, .y))))) %>%
  distinct(Var, .keep_all = TRUE) %>%
  select(-Var)
  
  return(adjacency.long)
  
}

```

# Create table of adjacent intervals


```{r}

my_table <- tibble(`Variable 1` = getTidyAdjacencyMatrix(PreToMid.fit) %>% pull(variable_name_1),
                   `Variable 2` = getTidyAdjacencyMatrix(PreToMid.fit) %>% pull(variable_name_2),
                   `Pre to Mid` = getTidyAdjacencyMatrix(PreToMid.fit) %>% pull(value),
                   `Mid To Post` = getTidyAdjacencyMatrix(MidToPost.fit) %>% pull(value),
                   `Post to 3M FU` = getTidyAdjacencyMatrix(PostTo3MFU.fit) %>% pull(value),
                   `3M FU to 6M FU` = getTidyAdjacencyMatrix(my3mTo6mFU.fit) %>% pull(value),
                   `Pre to Post` = getTidyAdjacencyMatrix(PreToPost.fit) %>% pull(value),
                   `Pre To 6M FU` = getTidyAdjacencyMatrix(PreTo6mFU.fit) %>% pull(value))
  
```

# Print with color gradient

```{r}

my_table %>%
  mutate_if(is.numeric, function(x) {
    cell_spec(x, color = spec_color(x, begin = 0, end = .6, option = "A"))}) %>%
  kable(escape = F, align = "c", caption = 'Adjacency Matrices of Networks Computed Over Intervals') %>%
  #kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  kable_classic(html_font = 'Times New Roman', full_width = FALSE) %>%
  column_spec(7:8, border_left = TRUE, border_right = TRUE)

```



