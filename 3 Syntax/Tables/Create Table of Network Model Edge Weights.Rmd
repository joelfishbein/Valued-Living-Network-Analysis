---
title: "Create Tables of Network Model Edge Weights"
output:
  html_document:
    toc: true
    toc_float: true
---

# Read in libraries and data
```{r}

library(tidyverse)
library(kableExtra)
library(here)


# Single timepoint models
Pre.fit <- read_rds(here('Fitted model objects','Pre.fit'))
Mid.fit <- read_rds(here('Fitted model objects','Mid.fit'))
Post.fit <- read_rds(here('Fitted model objects','Post.fit'))
my3mFU.fit <- read_rds(here('Fitted model objects','my3mFU.fit'))
my6mFU.fit <- read_rds(here('Fitted model objects','my6mFU.fit'))


PreToMid.fit <- read_rds(here('Fitted model objects','PreToMid.fit'))
MidToPost.fit <- read_rds(here('Fitted model objects','MidToPost.fit'))
PostTo3MFU.fit <- read_rds(here('Fitted model objects','PostTo3MFU.fit'))
my3mTo6mFU.fit <- read_rds(here('Fitted model objects','my3mTo6mFU.fit'))

PreToPost.fit <- read_rds(here('Fitted model objects','PreToPost.fit'))
PreTo6mFU.fit <- read_rds(here('Fitted model objects','PreTo6mFU.fit'))

```

# Set names of rows and columns

The network model itself does not store the names of the nodes, so input them here manually. Must match the order in which they were entered into the network.

```{r}

var_names <- tibble(names = c('ACTorMEUC','HADS','IESR','FCR','SCS','EAC','AAQc','CESD'))
```

# Generic function to create tidy adjacency matrix

```{r}


getTidyAdjacencyMatrix <- function(mgm_fit){
  
  # signs has 0s (undefined values) and NAs (non-sig edge values)
  # in it. We will just replace those with 1s for now.
  signs.tibble <- mgm_fit$pairwise$signs %>% 
    as_tibble() %>%
    mutate(across(everything(), ~replace(.x, .x %in% c(NA,0), 1)))
  
  adjacency.tibble <- mgm_fit$pairwise$wadj %>%
    as_tibble()
  
  # adjacency 
  adjacency_with_signs.tibble <- (signs.tibble * adjacency.tibble)
  
  
  adjacency.long <- 
    adjacency_with_signs.tibble %>%
    
    # rename columns as variable names
    rename_all(~var_names %>% pull(names)) %>%
    
    # add row names as variable names again
    mutate(variable_name_1 = var_names$names) %>%
    
    # format as long by variable 1 and variable 2
    pivot_longer(cols = ACTorMEUC:CESD, names_to = 'variable_name_2') %>%
    mutate(value = round(value,2)) %>%
    
    # remove redundant entries
    
   mutate(Var = map2_chr(variable_name_1, variable_name_2, ~toString(sort(c(.x, .y))))) %>%
  distinct(Var, .keep_all = TRUE) %>%
  select(-Var)
  
  return(adjacency.long)
  
}

```


# Create table of single timepoint models

## Get Pre adjacency matrix

```{r}

Pre.var_names <- tibble(names = c('HADS','IESR','FCR','SCS','EAC','AAQc','CESD'))

Pre.signs.tibble <- Pre.fit$pairwise$signs %>% 
    as_tibble() %>%
    mutate(across(everything(), ~replace(.x, .x %in% c(NA,0), 1)))
  
Pre.adjacency.tibble <- Pre.fit$pairwise$wadj %>%
    as_tibble()
  
  # adjacency 
  Pre.adjacency_with_signs.tibble <- (Pre.signs.tibble * Pre.adjacency.tibble)
  
  
Pre.adjacency.long <- 
    Pre.adjacency_with_signs.tibble %>%
    
    # rename columns as variable names
    rename_all(~Pre.var_names %>% pull(names)) %>%
    
    # add row names as variable names again
    mutate(variable_name_1 = Pre.var_names$names) %>%
    
    # format as long by variable 1 and variable 2
    pivot_longer(cols = HADS:CESD, names_to = 'variable_name_2') %>%
    mutate(value = round(value,2)) %>%
    
    # remove redundant entries
    
   mutate(Var = map2_chr(variable_name_1, variable_name_2, ~toString(sort(c(.x, .y))))) %>%
  distinct(Var, .keep_all = TRUE) %>%
  select(-Var)


Pre.adjacency.long
```

```{r}

single_timepoint_table <- left_join(getTidyAdjacencyMatrix(Mid.fit),
                         Pre.adjacency.long,
                        by = c("variable_name_1", "variable_name_2")) %>%
  rename(Pre = value.y, Mid = value.x) %>%
  relocate(Pre, .before = Mid) %>%
  mutate(Post = getTidyAdjacencyMatrix(Post.fit) %>% pull(value),
         `3m FU` = getTidyAdjacencyMatrix(my3mFU.fit) %>% pull(value),
         `6m FU` = getTidyAdjacencyMatrix(my6mFU.fit) %>% pull(value))

single_timepoint_table

```

# Print with color gradient

```{r}

single_timepoint_table %>%
  mutate_if(is.numeric, function(x) {
    cell_spec(x, color = spec_color(x, begin = 0, end = .6, option = "A"))}) %>%
  kable(escape = F, align = "c", caption = 'Adjacency Matrices of Networks Computed At Single Timepoints') %>%
  #kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  kable_classic(html_font = 'Times New Roman', full_width = FALSE)

```

# Create table of intervals


```{r}

my_table <- tibble(`Variable 1` = getTidyAdjacencyMatrix(PreToMid.fit) %>% pull(variable_name_1),
                   `Variable 2` = getTidyAdjacencyMatrix(PreToMid.fit) %>% pull(variable_name_2),
                   `Pre to Mid` = getTidyAdjacencyMatrix(PreToMid.fit) %>% pull(value),
                   `Mid To Post` = getTidyAdjacencyMatrix(MidToPost.fit) %>% pull(value),
                   `Post to 3M FU` = getTidyAdjacencyMatrix(PostTo3MFU.fit) %>% pull(value),
                   `3M FU to 6M FU` = getTidyAdjacencyMatrix(my3mTo6mFU.fit) %>% pull(value),
                   `Pre to Post` = getTidyAdjacencyMatrix(PreToPost.fit) %>% pull(value),
                   `Pre To 6M FU` = getTidyAdjacencyMatrix(PreTo6mFU.fit) %>% pull(value))
  
```

# Print with color gradient

```{r}

my_table %>%
  mutate_if(is.numeric, function(x) {
    cell_spec(x, color = spec_color(x, begin = 0, end = .6, option = "A"))}) %>%
  kable(escape = F, align = "c", caption = 'Adjacency Matrices of Networks Computed Over Intervals') %>%
  #kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  kable_classic(html_font = 'Times New Roman', full_width = FALSE) %>%
  column_spec(7:8, border_left = TRUE, border_right = TRUE)

```

